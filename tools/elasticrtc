#!/usr/bin/env python
##### IMPORTS #####
import os
import sys
if sys.version_info[0] > 2:
    print (  "\n====================================\n"
            +"\n   Python version not supported : " + str(sys.version_info[0]) + "." + str(sys.version_info[1]) + "\n"
            +"\n====================================\n")
    sys.exit(1)
def require (module, description):
    print ( "\n====================================\n"
            "\n   "+ description +" not installed. Execute as administrator:"
            "\n      pip install " + module +
            "\n"
            "\n   In order to install pip download from https://bootstrap.pypa.io/get-pip.py"
            "\n   and execute as adminstrator:"
            "\n"
            "\n      python get-pip.py"
            "\n====================================\n")
    sys.exit (1)

import subprocess
import getopt
import re
import datetime
import time
import json
import pprint
import ConfigParser
ConfigParser.DEFAULTSECT='default'
import hashlib
import collections
try:
    import OpenSSL.crypto as crypto
except Exception as e:
    require ('pyOpenSSL', 'Open SSL')
import ssl
import re
import operator
try:
    import boto3
except Exception as e:
    require ('boto3', 'AWS SDK')
try:
    import dns.resolver
except Exception as e:
    require ('dnspython', 'DNS module')

##### CONSTANTS #####
#KMS_AMI_NAME = 'KMS-CLUSTER-6.1.1.trusty-0.0.1-SNAPSHOT-20151115110730'
KMS_AMI_DESCRIPTION = 'kmscluster-controller'
ROOM_AMI_DESCRIPTION = 'kurento-room-sfu-demo'
TEMPLATE_FILE = "aws" + os.sep + "elasticrtc-template.json"
AWS_CONFIG_DIR = os.path.expanduser('~') + os.sep + '.aws'
AWS_CREDENTIALS_FILE = AWS_CONFIG_DIR + os.sep + 'credentials'
AWS_CONFIG_FILE = AWS_CONFIG_DIR + os.sep + 'config'
AWS_PROFILE = 'profile'
AWS_ACCESS_KEY_ID = 'aws_access_key_id'
AWS_SECRET_ACCESS_KEY = 'aws_secret_access_key'

# Error messages
LINE = "\n====================================\n"
CR = "\n"
I = "     "
I2 = I+I
I3 = I2+ "          "
CMD = "usage: " + os.path.basename(__file__) + " "
CMD_CREATE = "create"
CMD_DELETE = "delete"
CMD_LIST = "list"
CMD_SHOW = "show"
CMD_UPDATE = "update"
CMD_VERSION = "version"
CMDS = [ CMD_CREATE, CMD_DELETE, CMD_UPDATE, CMD_LIST, CMD_SHOW, CMD_VERSION ]

PARAM_APP_URL = "app-url"
PARAM_AWS_ACCESS_KEY_ID = "aws-access-key-id"
PARAM_AUTOSCALING_HEARTBEAT_TIMEOUT="autoscaling-heartbeat-timeout"
PARAM_AWS_INSTANCE_TENANCY = "aws-instance-tenancy"
PARAM_AWS_INSTANCE_TYPE = "aws-instance-type"
PARAM_AWS_APP_INSTANCE_TYPE = "aws-app-instance-type"
PARAM_AWS_KEY_NAME = "aws-key-name"
PARAM_AWS_S3_BUCKET_NAME = "aws-s3-bucket-name"
PARAM_AWS_SECRET_ACCESS_KEY = "aws-secret-access-key"
PARAM_CONTROL_ORIGIN = "control-origin"
PARAM_COST_MAP = "cost-map"
PARAM_DESIRED_CAPACITY = "desired-capacity"
PARAM_ELASTICSEARCH_TRANSPORT = "elasticsearch-transport"
PARAM_ELASTICSEARCH_USER = "elasticsearch-user"
PARAM_ELASTICSEARCH_PASS = "elasticsearch-password"
PARAM_ELASTICSEARCH_SSL = "elasticsearch-ssl"
PARAM_ENABLE_APP = "enable-app"
PARAM_ENABLE_TURN = "enable-turn"
PARAM_HEALTH_CHECK_GRACE_PERIOD = "health-check-grace-period"
PARAM_HOSTED_ZONE_ID = "hosted-zone-id"
PARAM_INSPECTOR_USER = "inspector-user"
PARAM_INSPECTOR_PASS = "inspector-pass"
PARAM_J = "j"
PARAM_KMSCLUSTER_CONTROLLER_URL="kmscluster-controller-url"
PARAM_KURENTO_API_KEY = "api-key"
PARAM_KURENTO_API_ORIGIN = "api-origin"
PARAM_LOG_STORAGE = "log-storage"
PARAM_MIN_CAPACITY = "min-capacity"
PARAM_MAX_CAPACITY = "max-capacity"
PARAM_REGION = "region"
PARAM_SESSION_RECONNECTION_TIME ="session-reconnection-time"
PARAM_SCALE_IN_POLICY = "scale-in-policy"
PARAM_SCALE_OUT_POLICY = "scale-out-policy"
PARAM_SSL_CERT = "ssl-cert"
PARAM_SSL_KEY = "ssl-key"
PARAM_STACK_NAME = "stack-name"
PARAM_TEST_MODE = "test-mode"
PARAM_USE_PROXY = "use-proxy"
PARAM_VERSION = "version"

# Usage Messages
USAGE_CLI = CMD + CR
USAGE_CLI_CREATE = CMD + CMD_CREATE + CR
USAGE_CLI_DELETE = CMD + CMD_DELETE + CR
USAGE_CLI_LIST = CMD + CMD_LIST + CR
USAGE_CLI_SHOW = CMD + CMD_SHOW + CR
USAGE_CLI_UPDATE = CMD + CMD_UPDATE + CR
USAGE_CLI_VERSION = CMD + CMD_VERSION + CR
USAGE_COMMAND_LIST = CR + I + "Commands:" + CR
USAGE_PARAM_LIST = CR + I + "Options:" + CR
USAGE_CREATE_CMD = I2 + CMD_CREATE + "  Create elasticRTC Cluster." + CR
USAGE_DELETE_CMD = I2 + CMD_DELETE + "  Delete elasticRTC Cluster." + CR
USAGE_LIST_CMD =   I2 + CMD_LIST + "    List elasticRTC Clusters." + CR
USAGE_SHOW_CMD =   I2 + CMD_SHOW + "    Show elasticRTC Cluster details." + CR
USAGE_SHOW_CMD =   I2 + CMD_UPDATE + "    Updates an already existing elasticRTC Cluster." + CR
USAGE_VERSION_CMD= I2 + CMD_VERSION + " List available version in region." + CR
USAGE_HELP_CMD = CR+I2 + "See '" + os.path.basename(__file__) + " help COMMAND' for help on a specific command." + CR

USAGE_AWS_ACCESS_KEY_ID = (CR+I2+ "--" + PARAM_AWS_ACCESS_KEY_ID + " value"
    +CR+I3+ "[Optional] Access Key Id required to connect AWS APIs. If not provided"
    +CR+I3+ "it will be used default configurations in file ~/.aws/credentials."
    +CR+I3+ "Go to following link for more info:"
    +CR+I3+ "  http://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSGettingStartedGuide/AWSCredentials.html"
    +CR)

USAGE_AWS_INSTANCE_TENANCY = (CR+I2+ "--" + PARAM_AWS_INSTANCE_TENANCY + " [default|dedicated|host]"
    +CR+I3+ "[Optional] EC2 tenancy of cluster nodes. Default value is default. For"
    +CR+I3+ "more information on EC2 dedicated instaces visit:"
    +CR+I3+ "http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/dedicated-instance.html"
    +CR)

USAGE_AWS_INSTANCE_TYPE = (CR+I2+ "--" + PARAM_AWS_INSTANCE_TYPE + " value"
    +CR+I3+ "[Optional] EC2 instance type used by cluster nodes. Default"
    +CR+I3+ "instance type is m3.medium"
    +CR
    +CR+I2+ "--" + PARAM_AWS_APP_INSTANCE_TYPE + " value"
    +CR+I3+ "[Optional] EC2 instance type used by app node when an APP is"
    +CR+I3+ "enabled. Same instance type of cluster nodes will be used if not"
    +CR+I3+ "specified"
    +CR)

USAGE_AWS_KEY_NAME = (CR+I2+ "--" + PARAM_AWS_KEY_NAME + " value"
    +CR+I3+ "[Optional] Name of Amazon EC2 key pair to be configured in nodes."
    +CR+I3+ "More information available in:"
    +CR+I3+ "http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-key-pairs.html"
    +CR)

USAGE_AWS_S3_BUCKET_NAME = (CR+I2+ "--" + PARAM_AWS_S3_BUCKET_NAME + " value"
    +CR+I3+ "[Optional] Name of Amazon S3 bucket used for permanent storage."
    +CR+I3+ "A new bucket named: <region>-<stack-name> will be created if this"
    +CR+I3+ "parameter is not provided. Notice buckets are never deleted on"
    +CR+I3+ "termination, even if they have been created by cluster tools."
    +CR)

USAGE_AWS_SECRET_ACCESS_KEY = (CR+I2+ "--" + PARAM_AWS_SECRET_ACCESS_KEY + " value"
    +CR+I3+ "[Optional] Secret Access Key required to connect AWS APIs. If not"
    +CR+I3+ "provided it will be used default configurations in file"
    +CR+I3+ "~/.aws/credentials. Go to following link for more info:"
    +CR+I3+ "  http://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSGettingStartedGuide/AWSCredentials.html"
    +CR)

USAGE_CONTROL_ORIGIN = (CR+I2 + "--" + PARAM_CONTROL_ORIGIN + " cidr"
    +CR+I3+ "[Optional] CIDR from where SSH connections will be allowed. Default"
    +CR+I3+ "value is 0.0.0.0/0, allowing connections from anywhere."
    +CR)

USAGE_COST_MAP = (CR+I2 + "--" + PARAM_COST_MAP + " key=value[,key=value ...]"
    +CR+I3+ "[Optional] Map of MediaElement costs for Load calculation. This flag"
    +CR+I3+ "accepts a comma separated list of key-value pairs with the cost description"
    +CR+I3+ "of each MediaElement."
    +CR)


USAGE_DESIRED_CAPACITY = (CR+I2 + "--" + PARAM_DESIRED_CAPACITY + " num"
    +CR+I3+ "[Optional] Number of KMS instances to be deployed by Kurento"
    +CR+I3+ "Cluster. AWS will take care to terminate failed instances in order"
    +CR+I3+ "to maintain desired cluster capacity. Desired capacity will default"
    +CR+I3+ "to minimun cluster capacity and then to 1 if no capacity configuration"
    +CR+I3+ "is provided. Visit http://docs.aws.amazon.com/AutoScaling/latest/DeveloperGuide/as-manual-scaling.html"
    +CR+I3+ "for more information on autoscaling."
    +CR)


USAGE_ENABLE_APP = (CR+I2+ "--" + PARAM_ENABLE_APP + " room"
    +CR+I3+ "[Optional] It deploys cluster with an embedded application. Currently"
    +CR+I3+ "only application ROOM is supported. Application will be accessible in"
    +CR+I3+ "URL: http[s]://cluster-url/app. HTTP or HTTPS will be used depending"
    +CR+I3+ "on SSL being enabled or not."
    +CR)

USAGE_ENABLE_TURN = (CR+I2+ "--" + PARAM_ENABLE_TURN + " (true|false)"
    +CR+I3+ "[Optional] Whether to enable or disable internal STUN/TURN server."
    +CR+I3+ "When enabled, each cluster node will run a TURN server protected"
    +CR+I3+ "by a random user and passwords. An IceServers object with all TURN"
    +CR+I3+ "URLs in cluster is provided in the Metadata object, that can be"
    +CR+I3+ "retrieved using Kurento client"
    +CR)

USAGE_INSPECTOR = (CR+I2 + "--" + PARAM_INSPECTOR_USER + " value"
    +CR+I3+ "[Optional] This username will be configured in the Inspector"
    +CR+I3+ "monitor application in order to control access to its web console."
    +CR+I3+ "Default value is admin."
    +CR
    +CR+I2+ "--" + PARAM_INSPECTOR_PASS + " num"
    +CR+I3+ "[Optional] This string will be configured as password for the"
    +CR+I3+ "Inspector application. Default value is admin."
    +CR)

USAGE_KURENTO_API_KEY = (CR+I2+ "--" + PARAM_KURENTO_API_KEY + " value"
    +CR+I3+ "[Optional] A secret string intended to control access to cluster"
    +CR+I3+ "API. Cluster will accept requests from any client presenting"
    +CR+I3+ "this key. This key is an alphanumeric non empty string of"
    +CR+I3+ "any length that is concatenated to the cluster URL:"
    +CR
    +CR+I3+ "       ws[s]://host/<"+ PARAM_KURENTO_API_KEY +">"
    +CR
    +CR+I3+ "Default value is kurento."
    +CR)

USAGE_KURENTO_API_ORIGIN = (CR+I2+ "--" + PARAM_KURENTO_API_ORIGIN + " cidr"
    +CR+I3+ "[Optional] CIDR from where KMS API request will be allowed. Default"
    +CR+I3+ "value is 0.0.0.0/0, allowing connections from anywhere."
    +CR)

USAGE_ENABLE_APP = (CR+I2+ "--" + PARAM_ENABLE_APP + " room"
    +CR+I3+ "[Optional] It deploys cluster with an embedded application. Currently"
    +CR+I3+ "only application ROOM is supported. Application will be accessible in"
    +CR+I3+ "URL: http[s]://cluster-url/app. HTTP or HTTPS will be used depending"
    +CR+I3+ "on SSL being enabled or not."
    +CR)

USAGE_LOG_STORAGE = (CR+I2+ "--" + PARAM_LOG_STORAGE + " [cloudwatch|s3|elasticsearch|none]"
    +CR+I3+ "[Optional] Storage location of logs. It can be any of AWS"
    +CR+I3+ "Cloudwatch Logs , AWS S3 services, an external Elasticsearch service"
    +CR+I3+ "or no cloud storage. If Elasticsearch is selected but no transport"
    +CR+I3+ "is provided, the system goes to default value: none"
    +CR
    +CR+I2+ "--" + PARAM_ELASTICSEARCH_TRANSPORT + " address[:port]"
    +CR+I3+ "[Optional] This flag must be provided when log storage is set to"
    +CR+I3+ "elasticsearch. It defines the transport address and port where the"
    +CR+I3+ "Elasticsearch service listens for requests. If no port is provided,"
    +CR+I3+ "default value, 9200, is used. If this flag is not provided when log"
    +CR+I3+ "storage is set to elasticsearch, then log storage defaults to cloudwatch"
    +CR
    +CR+I2+ "--" + PARAM_ELASTICSEARCH_USER + " value"
    +CR+I3+ "[Optional] Elasticsearch username. Anonymous access will be configured if"
    +CR+I3+ "not provided."
    +CR
    +CR+I2+ "--" + PARAM_ELASTICSEARCH_PASS + " value"
    +CR+I3+ "[Optional] Elasticsearch password. Anonymous access will be configured if"
    +CR+I3+ "not provided."
    +CR
    +CR+I2+ "--" + PARAM_ELASTICSEARCH_SSL + " boolean"
    +CR+I3+ "[Optional] Wheter to use SSL or not when connecting to Elasticsearch. Default"
    +CR+I3+ "value is false."
    +CR )

USAGE_MAX_CAPACITY = (CR+I2 + "--" + PARAM_MAX_CAPACITY + "num"
    +CR+I3+ "[Optional] Maximum number of nodes allowed in the cluster. Autoscaling"
    +CR+I3+ "is disabled if this configuration is not provided, even if a scale out"
    +CR+I3+ "policy is defined."
    +CR)

USAGE_MIN_CAPACITY = (CR+I2+ "--" + PARAM_MIN_CAPACITY + "num"
    +CR+I3+ "[Optional] Minimum number of nodes allowed in the cluster. Autoscaling"
    +CR+I3+ "is disabled if this configuration is not provided, even if a scale in"
    +CR+I3+ "policy is defined."
    +CR)

USAGE_REGION = (CR+I2+ "--"  + PARAM_REGION + " value"
    +CR+I3+ "[Mandatory] AWS region where cluster is deployed. Can be any of:"
    +CR+I3+ "  ap-northeast-1   Asia Pacific (Tokyo)"
    +CR+I3+ "  ap-southeast-1   Asia Pacific (Singapore)"
    +CR+I3+ "  ap-southeast-2   Asia Pacific (Sydney)"
    +CR+I3+ "  eu-central-1     EU (Frankfurt)"
    +CR+I3+ "  eu-west-1        EU (Ireland)"
    +CR+I3+ "  sa-east-1        South America (Sao Paulo)"
    +CR+I3+ "  us-east-1        US East (N. Virginia)"
    +CR+I3+ "  us-west-1        US West (N. California)"
    +CR+I3+ "  us-west-2        US West (Oregon)"
    +CR+I3+ "Visit http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html"
    +CR+I3+ "for more information."
    +CR)

USAGE_ROUTE53 =(CR+I2+ "--" + PARAM_HOSTED_ZONE_ID + " value"
    +CR+I3+ "[Optional] Route 53 hosted zone ID used by cluster to automatically"
    +CR+I3+ "register a CNAME record with the name of the stack. If a SSL"
    +CR+I3+ "certificate is provided its common name (CN) must match the hosted"
    +CR+I3+ "zone domain."
    +CR)

USAGE_SCALE_POLICY = (CR+I2 + "--" + PARAM_SCALE_IN_POLICY + "key=val[,key=val ...]"
    +CR+I3+ "[Optional] Set of key-value pairs with the definition of Load"
    +CR+I3+ "thresholds and their associated capacity reduction. A pair of"
    +CR+I3+ "the form 25=10 configures a reduction of 10% in capacity when"
    +CR+I3+ "load becomes 25 units lower than 50%. Default scale in policy"
    +CR+I3+ "is 25=10. "
    +CR
    +CR+I2 + "--" + PARAM_SCALE_OUT_POLICY + "key=val[,key=val ...]"
    +CR+I3+ "[Optional] Set of key-value pairs with the definition of Load"
    +CR+I3+ "thresholds and their associated capacity increase. A pair of"
    +CR+I3+ "the form 25=10 configures an increase of 10% in capacity when"
    +CR+I3+ "load becomes 25 units above 50%. Default scale out policy is"
    +CR+I3+ "25=10."
    +CR)

USAGE_STACK_NAME = (CR+I2+ "--" + PARAM_STACK_NAME + " value"
    +CR+I3+ "[Mandatory] Cluster name. It must start with letter, contain only"
    +CR+I3+ "alphanumeric characters and be unique in selected region. White"
    +CR+I3+ "spaces are not allowed."
    +CR)

USAGE_SSL = (CR+I2+ "--" + PARAM_SSL_CERT + " path"
    +CR+I3+ "[Optional] Path to the certificate file used for SSL connections."
    +CR+I3+ "Secure port will be blocked and wss protocol disabled if not provided."
    +CR+I3+ "Due to WebSocket limitation, autosigned certificates are not"
    +CR+I3+ "supported by cluster."
    +CR
    +CR+I2+ "--" + PARAM_SSL_KEY + " path"
    +CR+I3+ "[Optional] Path to the private key associated with SSL certificate. This"
    +CR+I3+ "parameter is mandatory if SSL certificate is provided."
    +CR)

USAGE_J = (CR+I2+ "-" + PARAM_J
    +CR+I3+ "[Optional] Intended for machine to machine interactions. Do not"
    +CR+I3+ "display debug messages and output is provided in JSON format suitable"
    +CR+I3+ "for parsing"
    +CR)

USAGE_VERSION = (CR+I2+ "--" + PARAM_VERSION + " version"
    +CR+I3+ "[Optional] Deploy cluster using this version. An error message is"
    +CR+I3+ "generated is requested version is not found in region. If no version"
    +CR+I3+ "is specified latest one is used."
    +CR)

USAGE_ALL = ( USAGE_CLI
            + USAGE_COMMAND_LIST
            + USAGE_CREATE_CMD
            + USAGE_DELETE_CMD
            + USAGE_LIST_CMD
            + USAGE_SHOW_CMD
            + USAGE_VERSION_CMD
            + USAGE_HELP_CMD
            + USAGE_PARAM_LIST
            + USAGE_J
            + USAGE_KURENTO_API_KEY
            + USAGE_KURENTO_API_ORIGIN
            + USAGE_AWS_ACCESS_KEY_ID
            + USAGE_AWS_SECRET_ACCESS_KEY
            + USAGE_AWS_KEY_NAME
            + USAGE_AWS_S3_BUCKET_NAME
            + USAGE_AWS_INSTANCE_TYPE
            + USAGE_AWS_INSTANCE_TENANCY
            + USAGE_CONTROL_ORIGIN
            + USAGE_COST_MAP
            + USAGE_DESIRED_CAPACITY
            + USAGE_ENABLE_APP
            + USAGE_ENABLE_TURN
            + USAGE_INSPECTOR
            + USAGE_LOG_STORAGE
            + USAGE_MAX_CAPACITY
            + USAGE_MIN_CAPACITY
            + USAGE_REGION
            + USAGE_ROUTE53
            + USAGE_SCALE_POLICY
            + USAGE_SSL
            + USAGE_STACK_NAME
            + USAGE_VERSION
            )

USAGE_CREATE = ( USAGE_CLI_CREATE
               + USAGE_J
               + USAGE_AWS_ACCESS_KEY_ID
               + USAGE_AWS_SECRET_ACCESS_KEY
               + USAGE_AWS_KEY_NAME
               + USAGE_AWS_S3_BUCKET_NAME
               + USAGE_AWS_INSTANCE_TYPE
               + USAGE_AWS_INSTANCE_TENANCY
               + USAGE_CONTROL_ORIGIN
               + USAGE_COST_MAP
               + USAGE_DESIRED_CAPACITY
               + USAGE_INSPECTOR
               + USAGE_KURENTO_API_KEY
               + USAGE_KURENTO_API_ORIGIN
               + USAGE_ENABLE_APP
               + USAGE_ENABLE_TURN
               + USAGE_LOG_STORAGE
               + USAGE_MAX_CAPACITY
               + USAGE_MIN_CAPACITY
               + USAGE_REGION
               + USAGE_ROUTE53
               + USAGE_SCALE_POLICY
               + USAGE_SSL
               + USAGE_STACK_NAME
               + USAGE_VERSION
               )

USAGE_DELETE = ( USAGE_CLI_DELETE
               + USAGE_REGION
               + USAGE_STACK_NAME)

USAGE_UPDATE = ( USAGE_CLI_UPDATE
               + USAGE_REGION
               + USAGE_STACK_NAME)

USAGE_LIST = ( USAGE_CLI_LIST
             + USAGE_J
             + USAGE_REGION
             )

USAGE_SHOW = ( USAGE_CLI_SHOW
             + USAGE_J
             + USAGE_REGION
             + USAGE_STACK_NAME
             )

USAGE_VERSION=(USAGE_CLI_VERSION
             + USAGE_J
             + USAGE_REGION
             )

ALPHANUMERIC_KURENTO_API_KEY = PARAM_KURENTO_API_KEY + " name must be an alphanumeric string"
ALPHANUMERIC_STACK_NAME = "Stack name must be an alphanumeric string"
MISSING_REGION = "Missing mandatory parameter --" + PARAM_REGION
MISSING_STACK_NAME = "Missing mandatory parameter --" + PARAM_STACK_NAME
MISSING_AWS_KEY_NAME = "Missing mandatory parameter --" + PARAM_AWS_KEY_NAME
MISSING_TEMPLATE = "CloudFormation template file not found: " + TEMPLATE_FILE
OPEN_TEMPLATE = "Unable to open CloudFormation template file: " + TEMPLATE_FILE
MIN_LARGER_MAX = "Minimun capacity is larger than maximum capacity"
SCALE_POLICY_BAD_FORMAT = "Wrong format for scale policy: num=num(,num=num)*"

##### LIBRARY ######
out_json = False
def usage (message, info):
    print (LINE)
    if not message is "":
        print (message) + CR
    print (info)
    print (LINE)
    sys.exit(1)

def log (message):
    if not out_json:
        print ("elasticRTC: " + message)

def log_warn (message):
    if not out_json:
        print ("WARN: " + message)

def log_error (message):
    print (LINE)
    print ("ERROR: " + message)
    print (LINE)
    sys.exit(1)

class KurentoClusterConfig:
    "Kurento Cluster Configuration"

    kurento_tools_home = os.path.dirname(__file__) + os.sep + ".."

    command = None

    aws_access_key_id = None
    aws_secret_access_key = None
    aws_key_name = None
    aws_s3_bucket_name = None
    aws_instance_type = None
    aws_app_instance_type = None
    aws_instance_tenancy = None
    cluster_fqdn = None
    control_origin = None
    cost_map = None
    desired_capacity = None
    elasticsearch_transport = None
    elasticsearch_user = None
    elasticsearch_pass = None
    elasticsearch_ssl = None
    enable_app = None
    enable_turn = None
    hosted_zone_fqdn = None
    hosted_zone_id = None
    inspector_user = None
    inspector_pass = None
    kurento_api_key = None
    kurento_api_origin = None
    log_storage = None
    max_capacity = None
    min_capacity = None
    region = None
    scale_in_policy = "25=10"
    scale_out_policy = "75=10"
    ssl_cert = None
    ssl_cert_chunks = []
    ssl_key= None
    ssl_common_name = None
    ssl_fqdn = None
    ssl_wildcard = None
    stack_name  = None
    template_file = kurento_tools_home + os.sep + TEMPLATE_FILE
    template_body = None
    turn_username = None
    turn_password = None
    version = None

    aws_param_mappings = {
        'CostMap' : PARAM_COST_MAP,
        'ControlOrigin' : PARAM_CONTROL_ORIGIN,
        'KeyName' : PARAM_AWS_KEY_NAME,
        'DesiredCapacity' : PARAM_DESIRED_CAPACITY,
        'MaxCapacity' : PARAM_MAX_CAPACITY,
        'MinCapacity' : PARAM_MIN_CAPACITY,
        'InspectorUser' : PARAM_INSPECTOR_USER,
        'InspectorPass' : PARAM_INSPECTOR_PASS,
        'InstanceTenancy' : PARAM_AWS_INSTANCE_TENANCY,
        'InstanceType' : PARAM_AWS_INSTANCE_TYPE,
        'AppInstanceType' : PARAM_AWS_APP_INSTANCE_TYPE,
        'ApiKey' : PARAM_KURENTO_API_KEY,
        'ApiOrigin' : PARAM_KURENTO_API_ORIGIN,
        'HostedZoneId' : PARAM_HOSTED_ZONE_ID,
        'UserS3Bucket' : PARAM_AWS_S3_BUCKET_NAME,
        'LogStorage' : PARAM_LOG_STORAGE,
        'ElasticSearchTransport' : PARAM_ELASTICSEARCH_TRANSPORT,
        'ElasticSearchUser' : PARAM_ELASTICSEARCH_USER,
        'ElasticSearchPass' : PARAM_ELASTICSEARCH_PASS,
        'ElasticSearchSsl' : PARAM_ELASTICSEARCH_SSL,
        'SslCertificate1' : PARAM_SSL_CERT,
        'SslKey' : PARAM_SSL_KEY,
        'Version' : PARAM_VERSION
    }

    # Internal parameter
    app_url = None
    autoscaling_heartbeat_timeout = None
    health_check_grace_period = None
    kms_controller_url = None
    session_reconnection_time = None
    test_mode = "false"
    use_proxy = "true"

    def __init__ (self, argv):
        if len(argv) == 0:
            usage ("", USAGE_ALL)
        elif argv[0] == 'help':
            if len(argv) > 1:
                usage ("", self._get_usage(argv[1]))
            usage ("", USAGE_ALL)
        self._read_command(argv[0])
        try:
            opts, args = getopt.getopt(argv[1:],"h" + PARAM_J ,[
                PARAM_AWS_ACCESS_KEY_ID + "=",
                PARAM_AUTOSCALING_HEARTBEAT_TIMEOUT + "=",
                PARAM_AWS_KEY_NAME + "=",
                PARAM_AWS_SECRET_ACCESS_KEY + "=",
                PARAM_AWS_S3_BUCKET_NAME + "=",
                PARAM_AWS_INSTANCE_TENANCY + "=",
                PARAM_AWS_INSTANCE_TYPE + "=",
                PARAM_AWS_APP_INSTANCE_TYPE + "=",
                PARAM_CONTROL_ORIGIN + "=",
                PARAM_COST_MAP + "=",
                PARAM_DESIRED_CAPACITY + "=",
                PARAM_ELASTICSEARCH_TRANSPORT + "=",
                PARAM_ELASTICSEARCH_USER + "=",
                PARAM_ELASTICSEARCH_PASS + "=",
                PARAM_ELASTICSEARCH_SSL + "=",
                PARAM_ENABLE_APP + "=",
                PARAM_ENABLE_TURN + "=",
                PARAM_INSPECTOR_USER + "=",
                PARAM_INSPECTOR_PASS + "=",
                PARAM_KURENTO_API_KEY + "=",
                PARAM_KURENTO_API_ORIGIN + "=",
                PARAM_HOSTED_ZONE_ID + "=",
                PARAM_LOG_STORAGE + "=",
                PARAM_MAX_CAPACITY + "=",
                PARAM_MIN_CAPACITY + "=",
                PARAM_REGION + "=",
                PARAM_SCALE_IN_POLICY + "=",
                PARAM_SCALE_OUT_POLICY + "=",
                PARAM_SSL_CERT + "=",
                PARAM_SSL_KEY + "=",
                PARAM_STACK_NAME + "=",
                "turn-username=",
                "turn-password=",
                PARAM_VERSION +"=",
                # Test parameters. Do not use in production
                PARAM_APP_URL + "=",
                PARAM_HEALTH_CHECK_GRACE_PERIOD + "=",
                PARAM_KMSCLUSTER_CONTROLLER_URL + "=",
                PARAM_SESSION_RECONNECTION_TIME + "=",
                PARAM_TEST_MODE + "=",
                PARAM_USE_PROXY + "="
            ])
            for opt, arg in opts:
                if opt == "-h":
                    usage ("", USAGE_ALL)
                elif opt == "-" + PARAM_J:
                    global out_json
                    out_json=True
                elif opt == "--" + PARAM_AWS_ACCESS_KEY_ID:
                    self.aws_access_key_id = arg
                elif opt == "--" + PARAM_AUTOSCALING_HEARTBEAT_TIMEOUT:
                    self.autoscaling_heartbeat_timeout = arg
                elif opt == "--" + PARAM_AWS_SECRET_ACCESS_KEY:
                    self.aws_secret_access_key = arg
                elif opt == "--" + PARAM_AWS_INSTANCE_TENANCY:
                    self.aws_instance_tenancy = arg
                elif opt == "--" + PARAM_AWS_INSTANCE_TYPE:
                    self.aws_instance_type = arg
                elif opt == "--" + PARAM_AWS_APP_INSTANCE_TYPE:
                    self.aws_app_instance_type = arg
                elif opt == "--" + PARAM_AWS_KEY_NAME:
                    self.aws_key_name = arg
                elif opt == "--" + PARAM_AWS_S3_BUCKET_NAME:
                    self.aws_s3_bucket_name = arg
                elif opt == "--" + PARAM_DESIRED_CAPACITY:
                    self.desired_capacity = arg
                elif opt == "--" + PARAM_ELASTICSEARCH_TRANSPORT:
                    self.elasticsearch_transport = arg
                elif opt == "--" + PARAM_ELASTICSEARCH_USER:
                    self.elasticsearch_user = arg
                elif opt == "--" + PARAM_ELASTICSEARCH_PASS:
                    self.elasticsearch_pass = arg
                elif opt == "--" + PARAM_ELASTICSEARCH_SSL:
                    self.elasticsearch_ssl = arg
                elif opt == "--" + PARAM_ENABLE_APP:
                    self.enable_app = arg
                elif opt == "--" + PARAM_ENABLE_TURN:
                    self.enable_turn = arg
                elif opt == "--" + PARAM_CONTROL_ORIGIN:
                    self.control_origin = arg
                elif opt == "--" + PARAM_COST_MAP:
                    self.cost_map = arg
                elif opt == "--" + PARAM_KURENTO_API_KEY:
                    self.kurento_api_key = arg
                elif opt == "--" + PARAM_KURENTO_API_ORIGIN:
                    self.kurento_api_origin = arg
                elif opt == "--" + PARAM_HOSTED_ZONE_ID:
                    self.hosted_zone_id = arg
                elif opt == "--" + PARAM_INSPECTOR_USER:
                    self.inspector_user = arg
                elif opt == "--" + PARAM_INSPECTOR_PASS:
                    #m = hashlib.md5()
                    #m.update(arg)
                    #self.inspector_pass = m.hexdigest()
                    self.inspector_pass = arg
                elif opt == "--" + PARAM_LOG_STORAGE:
                    self.log_storage = arg
                elif opt == "--" + PARAM_MAX_CAPACITY:
                    self.max_capacity = arg
                elif opt == "--" + PARAM_MIN_CAPACITY:
                    self.min_capacity = arg
                elif opt == "--" + PARAM_REGION:
                    self.region = arg
                elif opt == "--" + PARAM_SCALE_IN_POLICY:
                    self.scale_in_policy = arg
                elif opt == "--" + PARAM_SCALE_OUT_POLICY:
                    self.scale_out_policy = arg
                elif opt == "--" + PARAM_SSL_CERT:
                    self.ssl_cert = arg
                elif opt == "--" + PARAM_SSL_KEY:
                    self.ssl_key = arg
                elif opt == "--" + PARAM_STACK_NAME:
                    self.stack_name = arg
                elif opt == "--turn-username":
                    self.turn_username = arg
                elif opt == "--turn-password":
                    self.turn_password = arg
                elif opt == "--" + PARAM_VERSION:
                    self.version = arg
                # INTERNAL PARAMETERS
                elif opt == "--" + PARAM_APP_URL:
                    self.app_url = arg
                elif opt == "--" + PARAM_HEALTH_CHECK_GRACE_PERIOD:
                    self.health_check_grace_period = arg
                elif opt == "--" + PARAM_KMSCLUSTER_CONTROLLER_URL:
                    self.kms_controller_url = arg
                elif opt == "--" + PARAM_SESSION_RECONNECTION_TIME:
                    self.session_reconnection_time = arg
                elif opt == "--" + PARAM_TEST_MODE:
                    self.test_mode = arg
                elif opt == "--" + PARAM_USE_PROXY:
                    self.use_proxy = arg
                else:
                    usage("Unknown option: " + opt, USAGE_ALL)
        except Exception as e:
            usage ("Unable to parse command line options\n\n   " + str(e), USAGE_ALL)

    def _read_command(self, command):
        self._get_usage(command)
        self.command = command

    def _get_usage(self, command):
        try:
            return {
                CMD_CREATE : USAGE_CREATE,
                CMD_DELETE : USAGE_DELETE,
                CMD_LIST : USAGE_LIST,
                CMD_SHOW : USAGE_SHOW,
                CMD_UPDATE : USAGE_UPDATE,
                CMD_VERSION : USAGE_VERSION
                }[command]
        except Exception as e:
            usage ("Unknown command: " + command , USAGE_ALL)

class AwsSession:
    config  = None
    aws_session = None
    aws_credentials = []

    def __init__ (self, config):
        self.config = config
        self._create_aws_session()

    def _create_aws_session (self):
        try:
            if self.config.aws_access_key_id is None or self.config.aws_secret_access_key is None:
                self._get_aws_configuration()
                self._select_aws_credentials ()
            self.aws_session = boto3.Session(aws_access_key_id = self.config.aws_access_key_id,
                            aws_secret_access_key = self.config.aws_secret_access_key,
                            region_name = self.config.region)
        except Exception as e:
            log_error("Unable to create AWS session\n\n   " + str(e))

    def _select_aws_credentials (self):
        # Single profile
        if len(self.aws_credentials) == 1:
            self.config.aws_access_key_id = self.aws_credentials[0][AWS_ACCESS_KEY_ID]
            self.config.aws_secret_access_key = self.aws_credentials[0][AWS_SECRET_ACCESS_KEY]
            return
        # Multiple profile
        while True:
            menu = LINE + "Following AWS credential profiles have been found:\n"
            for i in range (0, len (self.aws_credentials)):
                menu += "   " + str(i+1) + " - " + self.aws_credentials[i][AWS_PROFILE] + "\n"
            menu += "Select credentials profile: "
            profile=0
            try:
                profile = int(raw_input(menu))
            except Exception as e:
                log_warn("Unable to get profile from input")
            if profile >= 1 and profile <= len(self.aws_credentials):
                self.config.aws_access_key_id = self.aws_credentials[profile - 1][AWS_ACCESS_KEY_ID]
                self.config.aws_secret_access_key = self.aws_credentials[profile - 1][AWS_SECRET_ACCESS_KEY]
                return
            print ("Invalid selection")

    def _get_aws_configuration (self):
        config_locations = [AWS_CREDENTIALS_FILE, AWS_CONFIG_FILE]
        for location in config_locations:
            if os.path.exists(location):
                aws_config = ConfigParser.RawConfigParser()
                aws_config.read(location)
                self._get_aws_credentials(aws_config)
        if len(self.aws_credentials) == 0:
            aws_config = self._gather_aws_credentials ()
            self._get_aws_credentials(aws_config)

    def _get_aws_credentials (self,aws_config):
        sections =  aws_config.sections() + [ConfigParser.DEFAULTSECT]
        for profile in sections:
            access = None
            secret = None
            if aws_config.has_option(profile, AWS_ACCESS_KEY_ID):
                access = aws_config.get(profile, AWS_ACCESS_KEY_ID)
            if aws_config.has_option(profile, AWS_SECRET_ACCESS_KEY):
                secret = aws_config.get(profile, AWS_SECRET_ACCESS_KEY)
            if not access is None and not secret is None:
                log ("Found AWS profile: " + profile)
                self.aws_credentials.append({
                    AWS_PROFILE : profile,
                    AWS_ACCESS_KEY_ID : access,
                    AWS_SECRET_ACCESS_KEY : secret
                })

    def _gather_aws_credentials(self):
        print (LINE +
              "AWS credentials not configured. Access and secret keys must be \n"
              "provided in order to allow Kurento tools to access AWS APIs.\n"
              "\n"
              "If you're the account administrator execute following procedure:\n"
              "  1 - Navigate to https://console.aws.amazon.com/iam/home?#security_credential\n"
              "  2 - Open section Access Keys (Access Key ID and Secret Access Key)\n"
              "  3 - Press button Create New Access Key\n"
              "\n"
              "If you're not the account administrator you still can generate credentials\n"
              "with following procedure\n"
              "  1 - Navigate to https://myaccount.signin.aws.amazon.com/console. Your AWS\n"
              "      administrator will provide you the value for myaccount\n"
              "  2 - Login to AWS console with you IAM user and password. Ask your AWS\n"
              "      administrator if you don't have an IAM user\n"
              "  3 - Navigate to IAM home https://console.aws.amazon.com/iam/home#home\n"
              "  4 - Open section 'Rotate your access keys' and click 'Manage User Access Key'\n"
              "  5 - Go to section 'Security Credentials' and click 'Create Access Key'\n"
              + LINE)
        aws_config = ConfigParser.RawConfigParser()
        while True:
            aws_access_key_id = raw_input ("Enter AWS Access Key ID:")
            if not aws_access_key_id is "":
                aws_config.set(ConfigParser.DEFAULTSECT, AWS_ACCESS_KEY_ID, aws_access_key_id)
                break
        while True:
            aws_secret_access_key = raw_input ("Enter AWS Secret Access Key:")
            if not aws_secret_access_key is "":
                aws_config.set(ConfigParser.DEFAULTSECT, AWS_SECRET_ACCESS_KEY, aws_secret_access_key)
                break
        if not os.path.exists(AWS_CONFIG_DIR):
            os.makedirs(AWS_CONFIG_DIR)
        aws_config.write (open(AWS_CREDENTIALS_FILE, 'w'))
        return aws_config

    def client (self,service):
        return self.aws_session.client(service)

class KurentoCluster:
    "Kurento Cluster"

    config = None
    template = None
    params = []
    default_params = []
    session = None
    images = {}
    stack = {}
    auto_scaling_groups = {}

    def __init__ (self, session, config):
        # Record basic config
        self.config = config
        self.session = session
        # Create AWS clients
        try:
            self.aws_cf = self.session.client('cloudformation')
            self.aws_autosc = self.session.client('autoscaling')
            self.aws_ec2 = self.session.client('ec2')
            self.aws_route53 = self.session.client('route53')
            self.aws_s3 = self.session.client('s3')
        except Exception as e:
            log_error("Unable to create AWS client\n\n   " + str(e))

        # Validate configuration
        self._validate_mandatory_parameters()
        if self.config.command == CMD_CREATE or self.config.command == CMD_UPDATE:
            self._validate_mandatory_parameters_stack ()
            self._validate_mandatory_parameters_create ()
            self._validate_s3 ()
            self._validate_autoscaling ()
            self._validate_route53 ()
            self._validate_ssl ()
            self._validate_dns ()

        elif self.config.command == CMD_DELETE:
            self._validate_mandatory_parameters_stack()

    def _validate_mandatory_parameters (self):
        if self.config.region is None:
            usage (MISSING_REGION, USAGE_REGION )

    def _validate_mandatory_parameters_stack (self):
        if self.config.stack_name is None:
            usage (MISSING_STACK_NAME, USAGE_STACK_NAME)
        if not self.config.stack_name.isalnum():
            usage (ALPHANUMERIC_STACK_NAME,USAGE_STACK_NAME)

    def _validate_mandatory_parameters_create (self):
        if os.path.exists(self.config.template_file):
            try:
                self.config.template_body = open(self.config.template_file).read()
            except Exception as e:
                log_error (OPEN_TEMPLATE + "\n\n   " + str(e))
        else:
            log_error (MISSING_TEMPLATE)
        if self.config.template_body is None:
            log_error ("Empty CloudFormation template body. Verify file exists: " + TEMPLATE_FILE )
        if not self.config.kurento_api_key is None and not self.config.kurento_api_key.isalnum():
            usage (ALPHANUMERIC_KURENTO_API_KEY, USAGE_KURENTO_API_KEY)

    def _validate_autoscaling (self):
        if self.config.min_capacity is None or self.config.max_capacity is None:
            if self.config.desired_capacity is None:
                self.config.desired_capacity = "1"
            self.config.min_capacity = self.config.desired_capacity
            self.config.max_capacity = self.config.desired_capacity
        elif self.config.min_capacity > self.config.max_capacity:
            log_error (MIN_LARGER_MAX)
        else:
            if self.config.desired_capacity is None:
                self.config.desired_capacity = self.config.min_capacity
        if not self.config.cost_map is None:
            if re.match("^\w+=\d+(,\w+=d\+)*", self.config.cost_map) is None:
                log_error("Param " + PARAM_COST_MAP + ". Bad format: " + self.config.cost_map)

    def _validate_s3 (self):
        if not self.config.aws_s3_bucket_name is None:
            try:
                self.aws_s3.head_bucket(
                    Bucket = self.config.aws_s3_bucket_name
                    )
                # Bucket exists and user has permissions
            except Exception as e:
                # Bucket does not exists or no permissions
                try:
                    self.aws_s3.create_bucket(
                        Bucket = self.config.aws_s3_bucket_name
                    )
                except Exception as e:
                    # No permissions
                    log_error("Unable to access bucket: "+ self.config.aws_s3_bucket_name + "\n\n   " + str(e))
        else:
            try:
                self.aws_s3.head_bucket(
                    Bucket = self.config.region + "-" + self.config.stack_name
                )
                # Bucket already exists => do not try to creae again
                self.config.aws_s3_bucket_name = self.config.region + "-" + self.config.stack_name
            except Exception as e:
                # Bucket does not exists or no permissions. Cloudformation will provide report
                log("Cluster will try to create bucket: " + self.config.region + "-" + self.config.stack_name)

    def _validate_route53 (self):
        if not self.config.hosted_zone_id  is None:
            try:
                hosted_zone = self.aws_route53.get_hosted_zone ( Id = self.config.hosted_zone_id )
            except Exception as e:
                log_error("Unable to get AWS hosted zone info\n\n   " + str(e))
            self.config.hosted_zone_fqdn = hosted_zone['HostedZone']['Name'].rstrip('.')

    def _validate_ssl (self):
        # SSL verifications
        if  not self.config.ssl_cert is None and self.config.ssl_key is None:
            usage ("Private Key must be provided with SSL certificate", USAGE_SSL)
        if self.config.ssl_cert is None:
            # Nothing to validate
            return

        cert = None
        priv = None
        pub = None

        # Verify PEM file exists for CERT
        if os.path.exists(self.config.ssl_cert):
            cert_str = open(self.config.ssl_cert).read()
            self.config.ssl_cert_chunks = [cert_str[i:i+4096] for i in range(0, len(cert_str), 4096)]
            cert = crypto.load_certificate (crypto.FILETYPE_PEM, cert_str)
            pub = cert.get_pubkey()
        else:
            usage ("SSL certificate not found or unable to open: " + self.config.ssl_cert, USAGE_SSL)

        # Verify PEM file exists for KEY
        if os.path.exists(self.config.ssl_key):
            priv_str = open(self.config.ssl_key).read()
            self.config.ssl_key_chunk=priv_str
            priv = crypto.load_privatekey(crypto.FILETYPE_PEM, priv_str)
        else:
            usage ("SSL private key not found or unable to open: " + self.config.ssl_key, USAGE_SSL)

        # Record SSL cert Common Name
        for cmp, val in cert.get_subject().get_components():
            if cmp == 'CN':
                self.config.ssl_common_name = val
                self.config.ssl_fqdn = val.lstrip('*').lstrip('.')
                # Check if certificate is wildcard
                if val.startswith('*.'):
                    self.config.ssl_wildcard = True
                    log ("Found wildcard certificate with CN: " + self.config.ssl_common_name)
                else:
                    self.config.ssl_wildcard = False
                    log ("Found certificate with CN: " + self.config.ssl_common_name)
                break

        # Validate Certificate matches hosted zone, if provided
        if not self.config.hosted_zone_fqdn is None:
            if ((self.config.ssl_wildcard == False and self.config.hosted_zone_fqdn != re.sub('^.+?\.','',self.config.ssl_fqdn)) or
                (self.config.ssl_wildcard == True and self.config.hosted_zone_fqdn != self.config.ssl_fqdn)):
                usage("SSL certificate name does not match hosted zone FQDN\n"
                  "\n  SSL common name   : " + self.config.ssl_common_name +
                  "\n  Hosted zone domain: " + self.config.hosted_zone_fqdn, USAGE_ROUTE53)

    def _validate_dns (self):
        if self.config.ssl_wildcard == False:
            self.config.cluster_fqdn = self.config.ssl_fqdn
        elif not self.config.hosted_zone_fqdn is None:
            self.config.cluster_fqdn = self.config.stack_name + "." + self.config.hosted_zone_fqdn
        elif not self.config.ssl_fqdn is None:
             self.config.cluster_fqdn = self.config.stack_name + "." + self.config.ssl_fqdn

    def _set_params (self):
        # Set parameters
        self._add_param ("KeyName", self.config.aws_key_name)
        self._add_param ("KurentoLoadBalancerName",(self.config.stack_name + "KurentoLoadBalancer")[:31])
        self._add_param ("DesiredCapacity",self.config.desired_capacity)
        self._add_param ("MaxCapacity", self.config.max_capacity)
        self._add_param ("MinCapacity", self.config.min_capacity)
        self._add_param ("InspectorUser", self.config.inspector_user)
        self._add_param ("InspectorPass", self.config.inspector_pass)
        self._add_param ("InstanceTenancy",self.config.aws_instance_tenancy)
        self._add_param ("InstanceType",self.config.aws_instance_type)
        self._add_param ("AppInstanceType", self.config.aws_app_instance_type if not self.config.aws_app_instance_type is None else self.config.aws_instance_type)
        self._add_param ("ApiKey",self.config.kurento_api_key)
        self._add_param ("ApiOrigin",self.config.kurento_api_origin)
        self._add_param ("ControlOrigin",self.config.control_origin)
        self._add_param ("CostMap",self.config.cost_map)
        self._add_param ("EnableTurn",self.config.enable_turn)
        self._add_param ("TurnUsername",self.config.turn_username)
        self._add_param ("TurnPassword",self.config.turn_password)
        self._add_param ("HostedZoneId",self.config.hosted_zone_id)
        self._add_param ("DnsName", self.config.cluster_fqdn)
        self._add_param ("UserS3Bucket", self.config.aws_s3_bucket_name)
        self._add_param ("LogStorage", self.config.log_storage)
        self._add_param ("ElasticSearchTransport", self.config.elasticsearch_transport)
        self._add_param ("ElasticSearchUser", self.config.elasticsearch_user)
        self._add_param ("ElasticSearchPass", self.config.elasticsearch_pass)
        self._add_param ("ElasticSearchSsl", self.config.elasticsearch_ssl)
        self._add_param ("Version", self.config.version)
        # Certificate must be split in chunks of 4096 due to AWS limitation
        for i in range (len(self.config.ssl_cert_chunks)):
            self._add_param("SslCertificate" + str(i+1), self.config.ssl_cert_chunks[i] )
            self._add_param("SslKey", self.config.ssl_key_chunk)
        # Set test parameter
        self._add_param ("AppUrl", self.config.app_url)
        self._add_param("AutoscalingHeartbeatTimeout", self.config.autoscaling_heartbeat_timeout)
        self._add_param ("HealthCheckGracePeriod",self.config.health_check_grace_period)
        self._add_param ("KmsControllerUrl", self.config.kms_controller_url)
        self._add_param ("SessionReconnectionTime" , self.config.session_reconnection_time)
        self._add_param ("TestMode", self.config.test_mode)
        self._add_param ("UseProxy", self.config.use_proxy)

    def _set_image_mapping_name (self):
        # Configure Cluster image name
        if 'cluster' in self.images:
            self._add_param('KmsImageMapName', 'cluster')
        else:
            log_error ("elasticRTC not supported in region: " + self.config.region)
        # Verify if any APP is being enabled
        app = self.config.enable_app
        if not app is None:
            if app != 'cluster' and app in self.images:
                self._add_param('AppImageMapName', app)
                self._add_param('EnableApp','true')
                self._add_param('AppName', app)
            else:
                log_error ("elasticRTC App: " + app +" not supported in region: " + self.config.region)

    def _build_cloudformation_template (self):
        # Get AWS images
        log ("Build CloudFormation template")
        #print self.config.template_body
        try:
            self.template = json.loads(self.config.template_body)
        except Exception as e:
            raise
            log_error ("Malformed CloudFormation template\n\n   " + str(e) )

        try:
            mappings = {}
            mappings['RegionMap']={}
            mappings['RegionMap'][self.config.region]={}
            for app in self.images:
                # Search AMI
                if not self.config.version is None:
                    if self.config.version in self.images[app]['Versions'].keys():
                        image_id = self.images[app]['Versions'][self.config.version]['latest_image_id']
                    else:
                        log_error ("App: " + app + " is not supported in region: " + self.config.region + " for version: " + self.config.version)
                else:
                    image_id = self.images[app]['latest_image_id']

                # Add AMI to mappings
                if not image_id is None:
                    mappings['RegionMap'][self.config.region][app]= image_id
                else:
                    log_error ("elasticRTC not supported in region: " + self.config.region)
            self.template['Mappings'] = mappings
            self.config.version = self.images['cluster']['latest_version']
        except Exception as e:
            raise
            log_error("Failure searching KMS AMI in region:" + self.config.region + "\n\n   " + str(e))

        # Calculate scaling policies
        step_in_policy = self._parse_step_policy(self.config.scale_in_policy)
        step_out_policy = self._parse_step_policy(self.config.scale_out_policy)

        # Write alarm thresholds to template
        l_th = int(step_in_policy[-1][0])
        h_th = int(step_out_policy[0][0])
        self.template['Resources']['KurentoUsageAlarmLow']['Properties']['Threshold'] = l_th
        self.template['Resources']['KurentoUsageAlarmHigh']['Properties']['Threshold'] = h_th

        # Write scale in step policy to template
        lower_bound = None
        for (b,c) in step_in_policy:
            step = {}
            if lower_bound:
                step['MetricIntervalLowerBound'] = lower_bound
            upper_bound = int(b) - l_th
            step['MetricIntervalUpperBound'] = upper_bound
            step['ScalingAdjustment'] = -int(c)
            self.template['Resources']['KurentoScaleDownPolicy']['Properties']['StepAdjustments'].append(step)
            lower_bound = upper_bound

        upper_bound = None
        for (b,c) in reversed(step_out_policy):
            step = {}
            if upper_bound:
                step['MetricIntervalUpperBound'] = upper_bound
            lower_bound = int(b) - h_th
            step['MetricIntervalLowerBound'] = lower_bound
            step['ScalingAdjustment'] = c
            self.template['Resources']['KurentoScaleUpPolicy']['Properties']['StepAdjustments'].append(step)
            upper_bound = lower_bound

    def _describe_images (self):
        blank = open(os.devnull, 'w')
        stdout=sys.stdout
        try:
            sys.stdout = blank
            aws_ec2 = self.session.client('ec2')
            cluster_images = aws_ec2.describe_images(
                Filters = [
                    {
                        'Name' : 'description',
                        'Values' : [ KMS_AMI_DESCRIPTION ,
                                     ROOM_AMI_DESCRIPTION
                        ]
                    }
                ]
            )
            sys.stdout=stdout
            self.images = {}
            for image in cluster_images['Images']:
                # Get image version
                version = re.search("KMS-(?P<version>\d+\.\d+\.\d+\S*)\.trusty",image['Name']).group('version')
                creation_ts = int(datetime.datetime.strptime(re.sub('\..*?$','',image['CreationDate']),"%Y-%m-%dT%H:%M:%S").strftime("%s"))
                app = re.match ("^(?P<app>(CLUSTER|ROOM))",image['Name']).group('app').lower()
                if not version is None:
                    if not app in self.images:
                        self.images[app] = {}
                        self.images[app]['latest_ts'] = 0
                        self.images[app]['Versions'] = {}
                    if not version in self.images[app]['Versions'].keys():
                        self.images[app]['Versions'][version]={}
                        self.images[app]['Versions'][version]['latest_ts'] = 0
                    if self.images[app]['Versions'][version]['latest_ts'] < creation_ts:
                        self.images[app]['Versions'][version]['latest_image_id'] = image['ImageId']
                        self.images[app]['Versions'][version]['latest_ts'] = creation_ts
                if self.images[app]['latest_ts'] < creation_ts:
                    self.images[app]['latest_image_id'] = image['ImageId']
                    self.images[app]['latest_ts'] = creation_ts
                    self.images[app]['latest_version'] = version

        except Exception as e:
            sys.stdout=stdout
            raise
            log_error("Failure searching ElasicRTC AMI in region: " + self.config.region + "\n\n   " + str(e))

        blank.close()

    def _get_image_app (self, image_id):
        for app in self.images:
            if self.images[app]['latest_image_id'] == image_id:
                return app
            if 'Versions' in self.images:
                for version in self.images['Versions']:
                    if version['latest_image_id'] == image_id:
                            return app
        return 'cluster'

    def _describe_stack (self):
        self.stack = {}
        try:
            # Get stack output data
            stack_list = self.aws_cf.describe_stacks ( StackName = self.config.stack_name )
            for s in stack_list['Stacks']:
                if s['StackName'] == self.config.stack_name:
                    # Collect status
                    self.stack['status'] = s['StackStatus']
                    # Collect params
                    self.stack['parameters'] = {}
                    if 'Parameters' in s:
                        for p in s['Parameters']:
                            self.stack['parameters'][p['ParameterKey']] = p['ParameterValue']
                    # Collect outputs
                    if 'Outputs' in s:
                        for output in s['Outputs']:
                            if output['OutputKey'] == 'URL':
                                self.stack['url'] = output['OutputValue']
                            elif output['OutputKey'] == 'AppURL':
                                self.stack['app_url'] = output['OutputValue']
                            elif output['OutputKey'] == 'AWSCname':
                                self.stack['aws-cname'] = output ['OutputValue']
                            elif output['OutputKey'] == 'ClusterCname':
                                self.stack['cluster-cname'] = output ['OutputValue']
                    break
            # Get resource details
            self.stack['dns_auto'] = False
            stack_resources = self.aws_cf.describe_stack_resources ( StackName = self.config.stack_name )
            for resource in stack_resources['StackResources']:
                if resource['LogicalResourceId'] == 'KurentoResourceSet':
                    self.stack['dns_auto'] = True
                    break
        except Exception as e:
            log_error("Unable to retrieve info from cluster stack:\n\n   " + str(e))

    def _describe_auto_scaling_groups (self):
        self.auto_scaling_groups = {}
        try:
            # Get autoscaling group name
            stack_resources = self.aws_cf.describe_stack_resources( StackName = self.config.stack_name )
            group_names = []
            for resource in stack_resources['StackResources']:
                if resource['ResourceType'] == 'AWS::AutoScaling::AutoScalingGroup':
                    group_names.append(resource['PhysicalResourceId'])

            groups = self.aws_autosc.describe_auto_scaling_groups ( AutoScalingGroupNames = group_names )
            for group in groups['AutoScalingGroups']:
                for instance in group['Instances']:
                    instance = self._describe_instance(instance['InstanceId'])
                    if not instance is None:
                        app = self._get_image_app (instance['image_id'])
                        if not app in self.auto_scaling_groups:
                            self.auto_scaling_groups[app] = {}
                            self.auto_scaling_groups[app]['instances'] = []
                        self.auto_scaling_groups[app]['instances'].append ( instance )
        except Exception as e:
            raise
            log_error("Unable to retrieve autoscaling group info:\n\n   " + str(e))

    def _describe_instance (self, instance_id):
        try:
            instance_info = self.aws_ec2.describe_instances( InstanceIds = [ instance_id ])
            if instance_info['Reservations'][0]['Instances'][0]['State']['Name'] == 'running':
                instance = {}
                instance['id'] = instance_id
                instance['public_ip'] = instance_info['Reservations'][0]['Instances'][0]['NetworkInterfaces'][0]['Association']['PublicIp']
                instance['private_ip'] = instance_info['Reservations'][0]['Instances'][0]['NetworkInterfaces'][0]['PrivateIpAddress']
                instance['type'] = instance_info['Reservations'][0]['Instances'][0]['InstanceType']
                instance['image_id'] = instance_info['Reservations'][0]['Instances'][0]['ImageId']
                return instance
            else:
                return None
        except Exception as e:
            raise
            log_error("Unable to retrieve instance info:\n\n   " + str(e))

    def _parse_step_policy (self, step_policy_str):
        step_policy = {}
        if not re.match("^\d+=\d+(,\d+=\d+)*$", step_policy_str):
            log_error (SCALE_POLICY_BAD_FORMAT + " : " + step_policy_str)
        for step in re.finditer ("(?P<bound>\d+)=(?P<change>\d+)", step_policy_str):
            step_policy[step.group('bound')]=step.group('change')
        return sorted(step_policy.items())

    def _add_param (self, parameter_key, parameter_value):
        if parameter_value is None:
            # If not specified in CLI then get current value from stack
            if parameter_key in self.default_params:
                parameter_value = self.default_params[parameter_key]
        if not parameter_value is None and parameter_value != 'default':
            self.params.append ({
                "ParameterKey" : parameter_key,
                "ParameterValue" : parameter_value
            })

    def _wait_cf_cmd (self, wait_state, end_state, message):
        if not out_json:
            sys.stdout.write(message)
            sys.stdout.flush()
        blank = open(os.devnull, 'w')
        stdout=sys.stdout
        while True:
            try:
                # boto3 is printing data to STDOUT
                sys.stdout = blank
                request = self.aws_cf.describe_stacks ( StackName = self.config.stack_name )
                event_report = self.aws_cf.describe_stack_events ( StackName = self.config.stack_name )
                sys.stdout=stdout
            except Exception as e:
                sys.stdout=stdout
                if 'exist' in str(e):
                    # This is very specific for command delete
                    request['Stacks'][0]['StackStatus'] = end_state
                else:
                    log_error("Unable to retrieve info for stack: " + self.config.stack_name)

            if len (request['Stacks']) == 1:
                status = request['Stacks'][0]
                if status['StackStatus'] in wait_state:
                    if not out_json:
                        sys.stdout.write('.')
                        sys.stdout.flush()
                elif status['StackStatus'] in end_state:
                    if not out_json:
                        sys.stdout.write('[OK]\n')
                        sys.stdout.flush()
                    break
                else:
                    fail_reason = ""
                    for event in event_report['StackEvents']:
                        if 'FAILED' in event['ResourceStatus']:
                            fail_reason += event['ResourceStatusReason'] + '\n'
                    log_error ("Unsupported AWS status: " + status['StackStatus'] + "\n\n" + fail_reason)
            elif len (request['Stacks']) == 0:
                log_error("AWS reports unknown stack: " + self.config.stack_name )
            else:
                log_error("AWS reports to many stacks:\n\n " + resquest)
            time.sleep(5)
        blank.close()

    def _create (self):
        # Build CloudFormation stack
        log ("Start CloudFormation stack: " + self.config.stack_name )
        self._describe_images ()
        self._build_cloudformation_template ()
        self._set_image_mapping_name ()
        self._set_params ()

        blank = open(os.devnull, 'w')
        stdout=sys.stdout
        try:
            sys.stdout = blank
            self.aws_cf.create_stack(
                StackName = self.config.stack_name,
                TemplateBody = json.dumps(self.template),
                Capabilities = [
                    'CAPABILITY_IAM',
                ],
                Parameters = self.params
            )
            sys.stdout = stdout
        except Exception as e:
            sys.stdout = stdout
            log_error("CloudFormation did not complete creation of stack: " + self.config.stack_name +
                " due to:\n\n   " + str(e))
        self._wait_cf_cmd('CREATE_IN_PROGRESS', 'CREATE_COMPLETE', 'Creating cluster')
        # Wait for DNS name to be available
        if not self.config.hosted_zone_fqdn is None:
            resolver = dns.resolver.Resolver()
            while True:
                dns_info = []
                try:
                    dns_info = resolver.query(self.config.cluster_fqdn, 'CNAME')
                except Exception as e:
                    log("Resolver error waiting DNS record: " + str(e))
                if len (dns_info) > 0 :
                    break
                time.sleep (5)

        # Print stack details
        self._show()

    def _delete (self):
        log ("Delete CloudFormation stack: " + self.config.stack_name )
        blank = open(os.devnull, 'w')
        stdout=sys.stdout
        try:
            # Do not delete any stack not being Kurento Cluster
            sys.stdout = blank
            request = self.aws_cf.get_template(StackName = self.config.stack_name)
            if not 'KurentoCluster' in request['TemplateBody']['Parameters']:
                log_error("Not an elasticRTC Cluster: " + self.config.stack_name)
            self.aws_cf.delete_stack(StackName = self.config.stack_name)
            sys.stdout = stdout
        except Exception as e:
            sys.stdout = stdout
            log_error("CloudFormation did not complete deletion of stack: " + self.config.stack_name +
                " due to:\n\n   " + str(e))

        self._wait_cf_cmd('DELETE_IN_PROGRESS', 'DELETE_COMPLETE', 'Deleting cluster')

    def _update (self):
        log ("Update CloudFormation stack: " + self.config.stack_name )
        # Get current stack
        stack = self._describe_stack ()
        self.default_params = stack['parameters']
        # Build updated template and set params
        self._build_cloudformation_template ()
        self._set_image_mapping_name ()
        self._set_params ()

        blank = open(os.devnull, 'w')
        stdout=sys.stdout
        try:
            sys.stdout = blank
            self.aws_cf.update_stack(
                StackName = self.config.stack_name,
                TemplateBody = json.dumps(self.template),
                Capabilities = [
                    'CAPABILITY_IAM',
                ],
                Parameters = self.params
            )
            sys.stdout = stdout
        except Exception as e:
            sys.stdout = stdout
            raise
            log_error("CloudFormation did not complete update of stack: " + self.config.stack_name +
                " due to:\n\n   " + str(e))
        self._wait_cf_cmd('UPDATE_IN_PROGRESS', 'UPDATE_COMPLETE', 'Updating cluster')

    def _list (self):
        res_str = LINE + "List elasticRTC stacks:" +CR
        res_obj = []
        try:
            for stack in self.aws_cf.list_stacks()['StackSummaries']:
                if self.config.region in stack['StackId'] and stack['StackStatus'] != 'DELETE_COMPLETE':
                    request = self.aws_cf.get_template(StackName = stack['StackName'])
                    if 'KurentoCluster' in request['TemplateBody']['Parameters']:
                        res_str += I + "Name: " + stack['StackName'] + ", Status: " + stack['StackStatus'] +CR
                        res_stack = {}
                        res_stack['name'] = stack['StackName']
                        res_stack['status'] = stack['StackStatus']
                        res_obj.append (res_stack)
            res_str += LINE
        except Exception as e:
            log_error("Unable to retrieve list of clusters due to:\n\n   " + str(e))
        if out_json == True:
            res_str = json.dumps (res_obj)
        print (res_str)

    def _show (self):
        res_str = ""
        res_obj = {}
        cluster = {}
        dns_notice = ""
        try:
            # Get cluster info
            self._describe_images ()
            self._describe_stack()
            self._describe_auto_scaling_groups ()

            # print cluster INFO
            res_str += LINE
            res_str += "elasticRTC Cluster:" + self.config.stack_name + CR
            # Show Status
            res_str += CR+I + "Status:" + CR
            res_str += I2 + self.stack['status'] + CR
            res_obj['Status'] = self.stack['status']
            # Show version
            ami = self.auto_scaling_groups['cluster']['instances'][0]['image_id']
            version = 'unknown'
            for v in self.images['cluster']['Versions']:
                if self.images['cluster']['Versions'][v]['latest_image_id'] == ami:
                    version = v
            res_str += CR+I + "Version: " + CR
            res_str += I2 + version + CR
            res_obj['Version'] = version
            # Show Cluster URL
            if 'url' in self.stack:
                res_str += CR+I + "Cluster URL:" + CR
                res_str += I2 + self.stack['url'] + CR
                res_obj['ClusterUrl'] = self.stack['url']
            if not self.stack['dns_auto'] and 'cluster-cname' in self.stack and not self.stack['cluster-cname'] == '':
                dns_notice += I2 + "Note: Following CNAME record must be manually created: " + CR
                dns_notice += I2 + "    " + self.stack['cluster-cname'] + "  CNAME  " + self.stack['aws-cname'] + CR
                res_str += dns_notice
            # Show cluster instances
            res_obj['ClusterInstances'] = []
            res_str += CR+I + "Cluster Instances: " +  str(len (self.auto_scaling_groups['cluster']['instances'])) + CR
            for instance in self.auto_scaling_groups['cluster']['instances']:
                res_str += I2 + instance['id'] + ": " + instance['type'] + " - " + instance['private_ip']+ "/" + instance['public_ip'] + CR
                res_instance = {}
                res_instance['id'] = instance['id']
                res_instance['private_ip'] = instance['private_ip']
                res_instance['public_ip'] = instance['public_ip']
                res_instance['type'] = instance['type']
                res_obj['ClusterInstances'].append(res_instance)
            # Show app name
            res_str += CR+I + "APP: " + CR
            if 'app_url' in self.stack:
                res_str += I2 + self.stack['parameters']['AppName'] + CR
                res_obj['Application'] = self.config.enable_app
            else:
                res_str += I2 + "none" + CR
                res_obj['Application'] = 'none'
            # Show App URL
            if 'app_url' in self.stack:
                res_str += CR+I + "App URL:" + CR
                res_str += I2 + self.stack['app_url'] + CR
                res_str += dns_notice
                res_obj['AppUrl'] = self.stack['app_url']
            # Show App instances
            if 'AppName' in self.stack['parameters'] and self.stack['parameters']['AppName'] in self.auto_scaling_groups:
                app = self.stack['parameters']['AppName']
                res_obj['AppInstances'] = []
                res_str += CR+I + "App Instances: " +  str(len (self.auto_scaling_groups[app]['instances'])) + CR
                for instance in self.auto_scaling_groups[app]['instances']:
                    res_str += I2 + instance['id'] + ": " + instance['type'] + " - " + instance['private_ip']+ "/" + instance['public_ip'] + CR
                    res_instance = {}
                    res_instance['id'] = instance['id']
                    res_instance['private_ip'] = instance['private_ip']
                    res_instance['public_ip'] = instance['public_ip']
                    res_instance['type'] = instance['type']
                    res_obj['AppInstances'].append(res_instance)
            # Show build parameters
            res_obj['Parameters'] = {}
            res_str += CR+I + "Build parameters:" + CR
            col_width = max(len(self.config.aws_param_mappings[key]) for key in self.config.aws_param_mappings) + 1
            for aws_param in sorted(self.config.aws_param_mappings, key=self.config.aws_param_mappings.get):
                param_lines = self.stack['parameters'][aws_param].splitlines()
                if len(param_lines) > 0:
                    param_value = param_lines[0]
                else:
                    param_value = ""
                res_str += I2 + self.config.aws_param_mappings[aws_param].ljust(col_width) + ": " + param_value + CR
                for line in param_lines[1:]:
                    res_str += I2 + "".ljust(col_width +2 ) + line + CR
                res_obj['Parameters'][aws_param] = self.stack['parameters'][aws_param]
            res_str += LINE
        except Exception as e:
            raise
            log_error("Unable to retrieve cluster info:\n\n   " + str(e))
        if out_json == True:
            res_str = json.dumps(res_obj)
        print res_str

    def _version (self):
        res_str = ""
        res_obj = {}
        self._describe_images ()
        res_str += LINE
        res_str += "elasticRTC versions: " + CR
        res_obj= {}
        res_obj['Versions'] = []
        for version in sorted(self.images['cluster']['Versions']):
            res_str += I2 + version + CR
            res_obj['Versions'].append(version)
        res_str += LINE
        if out_json == True:
            res_str = json.dumps(res_obj)
        print res_str

    def execute (self):
        if self.config.command == CMD_CREATE:
            self._create()
        elif self.config.command == CMD_DELETE:
            self._delete()
        elif self.config.command == CMD_LIST:
            self._list()
        elif self.config.command == CMD_SHOW:
            self._show()
        elif self.config.command == CMD_UPDATE:
            self._update()
        elif self.config.command == CMD_VERSION:
            self._version()
        else:
            usage ("Unknown command: " + self.config.command, USAGE_ALL)

##### MAIN #####

# Parse command line arguments
config = KurentoClusterConfig(sys.argv[1:])
session = AwsSession(config)

# Execute cluster command
cluster = KurentoCluster(session, config)
cluster.execute()

# TODO: Autoscaling
# TODO: Runtime cluster reconfiguration
